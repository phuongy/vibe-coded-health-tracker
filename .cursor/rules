# Cursor Rules for Health Tracker Project

## Project Overview
This is a health tracking application built with Remix, React, TypeScript, and shadcn/ui components. The project uses Tailwind CSS for styling, follows modern React patterns with Feature-Sliced Design (FSD) architecture and Atomic Design principles, and includes full internationalization (i18n) support.

## Technology Stack
- **Framework**: Remix with Vite
- **Language**: TypeScript (strict mode)
- **Styling**: Tailwind CSS with shadcn/ui components
- **Icons**: Lucide React
- **Theme**: Dark/light mode with next-themes
- **Internationalization**: react-i18next with language detection
- **Forms**: react-hook-form with zod validation
- **UI Components**: Radix UI primitives with shadcn/ui
- **Package Manager**: pnpm
- **Navigation**: React Router with active link highlighting
- **Linting**: ESLint with TypeScript support
- **Build Tool**: Vite with Remix integration

## Code Style & Conventions

### React Import Style
- **Always use namespace imports**: `import * as React from "react"`
- **Never use default imports**: Don't use `import React from "react"`
- **Use React namespace**: Access hooks as `React.useState`, `React.useEffect`, etc.
- **Remove unused imports**: Only import React when actually using React hooks or JSX

### File Organization
- Use `@/` alias for imports from the app directory (configured in tsconfig.json)
- Follow Feature-Sliced Design (FSD) architecture:
  - **app**: `app/` - Application configuration, providers, routing, i18n setup
  - **pages**: `app/routes/` - Page components and routing
  - **widgets**: `components/widgets/` - Self-contained page sections
  - **features**: `features/` - Business logic and user interactions
  - **entities**: `entities/` - Business entities and their logic
  - **shared**: `shared/` - Reusable utilities, UI components, types, i18n config
- Follow Atomic Design principles for component organization within shared:
  - **Atoms**: `shared/ui/atoms/` - Basic building blocks (Button, Card, Switch, Input, Select, Dialog, Form, Label)
  - **Molecules**: `shared/ui/molecules/` - Simple combinations (ThemeToggle, LanguageSwitcher)
  - **Organisms**: `shared/ui/organisms/` - Complex UI sections
- Each UI component lives in its own directory with the component file named after the component
- shadcn/ui components go in `shared/ui/atoms/`
- Utilities go in `shared/lib/`
- API functions go in `shared/lib/api.ts`
- i18n configuration goes in `shared/lib/i18n.ts`
- Theme provider goes in `shared/provider/theme-provider.tsx`

### Import Patterns
- **Always use `@/` alias**: Never use `~` for imports
- **Direct imports**: Import directly from component files, not index files
- **Component imports**: `@/shared/ui/atoms/button/button`
- **Widget imports**: `@/components/widgets/health-stats`
- **Feature imports**: `@/features/dashboard`
- **Entity imports**: `@/entities/user`
- **Utility imports**: `@/shared/lib/utils`
- **API imports**: `@/shared/lib/api`
- **i18n imports**: `@/shared/lib/i18n`
- **App components**: `@/app/components/app-header`, `@/app/components/app-footer`
- **Provider imports**: `@/shared/provider/theme-provider`

### Import Order
1. React and external libraries
2. Internal components and utilities (using @/ alias)
3. Relative imports
4. Type imports
5. **ESLint enforced**: Use `pnpm lint --fix` to auto-fix import order

### FSD Import Rules
- **Dependency Direction**: Higher layers can import from lower layers
  - app → pages → widgets → features → entities → shared
- **No Circular Dependencies**: Lower layers cannot import from higher layers
- **No Index Files**: Import directly from component files
- **Absolute Imports**: Use `@/` alias for cross-slice imports
- **Valid Exports**: Only export files that actually exist

### Component Guidelines
- Use functional components with TypeScript
- Prefer shadcn/ui components over custom implementations
- Use proper TypeScript types and interfaces
- Follow React hooks best practices
- Use proper accessibility attributes
- Each component should be in its own directory with descriptive filename
- Always use `import * as React from "react"` pattern when using React hooks
- Remove unused React imports from components that don't use hooks
- Extract repeated classnames into helper functions for maintainability

### Internationalization (i18n)
- **Always use translation keys**: Never hardcode strings in components
- **Use useTranslation hook**: `const { t } = useTranslation()`
- **Translation keys**: Use descriptive, nested keys (e.g., `t("dashboard.title")`)
- **Translation files**: All translations in `shared/lib/i18n.ts`
- **Supported languages**: English (en), Spanish (es), French (fr)
- **Language detection**: Automatic with localStorage fallback, defaults to English
- **Error messages**: All error messages must be translatable
- **Units and values**: All units and health metrics must be translatable
- **Language selector**: Located in footer, no flag emojis
- **Hook dependencies**: Include `t` in useEffect dependency arrays when used inside effects

### API Patterns
- **Mock API functions**: Use `shared/lib/api.ts` for mock data
- **Error handling**: All API errors must be translatable
- **Loading states**: Implement proper loading states for all API calls
- **Error states**: Implement proper error states with translated messages
- **API error constants**: Use `API_ERRORS` object for consistent error messages
- **Simulated delays**: Use realistic network delays for better UX

### Form Handling
- **react-hook-form**: Use for form state management
- **zod validation**: Use for form validation schemas
- **Translated validation**: All validation messages must be translatable
- **Proper error handling**: Handle form submission errors gracefully
- **Loading states**: Show loading states during form submission
- **Default values**: Support pre-selected values for forms (e.g., stat types)

### Styling Guidelines
- Use Tailwind CSS classes
- Prefer CSS variables for theming (already configured)
- Use shadcn/ui design tokens
- Support both light and dark themes
- Use responsive design patterns
- Use proper color contrast ratios
- Extract repeated classnames into helper functions
- Use nullish coalescing (`??`) instead of logical OR (`||`) for fallback values

### TypeScript Best Practices
- Use strict TypeScript configuration
- Define proper interfaces for props
- Use proper type annotations
- Avoid `any` types
- Use proper generic types where needed
- Use proper type inference where possible
- Fix all TypeScript errors before committing

## Component Patterns

### Feature-Sliced Design (FSD) Architecture
- **app**: Application layer
  - Configuration, providers, routing setup
  - Global styles and theme providers
  - App-wide state management
  - i18n initialization and configuration
  - Global components: AppHeader, AppFooter
- **pages**: Page components
  - Route components with page-specific logic
  - Data fetching and page-level state
  - Composition of widgets and features
  - Dashboard as initial page (`/dashboard`)
  - Stat type pages: `/weight`, `/heart-rate`, `/sleep`, `/steps`
- **widgets**: Self-contained page sections
  - Complex UI components that combine features
  - Page-specific business logic
  - Reusable across different pages
  - API data fetching and state management
- **features**: Business logic and user interactions
  - User actions and business processes
  - Feature-specific state management
  - API calls and data transformations
  - Form handling and validation
  - AddEntryModal with pre-selected stat types
- **entities**: Business entities
  - Data models and business logic
  - Entity-specific operations
  - Domain-driven design principles
- **shared**: Reusable utilities and components
  - UI components, utilities, types
  - No business logic, pure functionality
  - Framework-agnostic code
  - i18n configuration and API utilities

### Atomic Design Principles (within shared/ui)
- **Atoms**: Smallest functional units
  - `shared/ui/atoms/button/button.tsx` - Basic button component
  - `shared/ui/atoms/card/card.tsx` - Basic card component
  - `shared/ui/atoms/switch/switch.tsx` - Basic switch component
  - `shared/ui/atoms/input/input.tsx` - Basic input component
  - `shared/ui/atoms/select/select.tsx` - Basic select component
  - `shared/ui/atoms/dialog/dialog.tsx` - Basic dialog component
  - `shared/ui/atoms/form/form.tsx` - Form components with react-hook-form
  - `shared/ui/atoms/label/label.tsx` - Basic label component
  - Should be highly reusable and configurable
  - Minimal business logic
  - Focus on presentation and interaction
- **Molecules**: Simple combinations of atoms
  - `shared/ui/molecules/theme-toggle/theme-toggle.tsx` - Combines Switch + Icons
  - `shared/ui/molecules/language-switcher/language-switcher.tsx` - Language selection (no flag emojis)
  - Combine 2-3 atoms with simple logic
  - Handle basic state and interactions
  - Still reusable across different contexts
- **Organisms**: Complex UI sections
  - Combine multiple molecules and atoms
  - Handle complex state and business logic
  - Specific to particular use cases

### Component Directory Structure
```
shared/ui/
├── atoms/
│   ├── button/
│   │   └── button.tsx
│   ├── card/
│   │   └── card.tsx
│   ├── switch/
│   │   └── switch.tsx
│   ├── input/
│   │   └── input.tsx
│   ├── select/
│   │   └── select.tsx
│   ├── dialog/
│   │   └── dialog.tsx
│   ├── form/
│   │   └── form.tsx
│   └── label/
│       └── label.tsx
├── molecules/
│   ├── theme-toggle/
│   │   └── theme-toggle.tsx
│   └── language-switcher/
│       └── language-switcher.tsx
└── organisms/
    └── (future complex components)
```

### App Components
- **AppHeader**: Global navigation header with active link highlighting
  - Dashboard title link
  - Stat type navigation links (Weight, Heart Rate, Sleep, Steps)
  - Theme toggle
  - Add entry modal trigger
  - Active link highlighting with background accent
  - Extracted classname helper functions for maintainability
- **AppFooter**: Global footer with language switcher
  - Centered language switcher
  - Border-top styling
  - Consistent across all pages

### Navigation Patterns
- **Active Link Highlighting**: Use `useLocation` hook for current path detection
- **Extracted Classnames**: Use helper functions for navigation link styling
- **Dashboard as Home**: Dashboard is the initial page, no separate home page
- **Stat Type Pages**: Each stat type has its own dedicated page
- **Consistent Layout**: All pages include AppHeader and AppFooter

### shadcn/ui Components
- Always use shadcn/ui components when available
- Follow the established component patterns
- Use proper variants and sizes
- Maintain accessibility standards
- Place in appropriate atomic design layer
- Use Radix UI primitives as base

### Theme Integration
- Use CSS variables for colors
- Support dark/light mode switching
- Use proper contrast ratios
- Test both themes
- ThemeToggle component handles theme switching
- LanguageSwitcher component handles language switching

### Form Handling
- Use react-hook-form for form state
- Use zod for validation schemas
- Use proper form validation with translated messages
- Follow Remix form patterns
- Use proper error handling
- Implement proper loading states
- Support pre-selected values (e.g., default stat type in AddEntryModal)

## File Naming Conventions
- Use kebab-case for file names
- Use PascalCase for component names
- Use camelCase for functions and variables
- Use UPPER_SNAKE_CASE for constants
- Component files should be named after the component (e.g., `button.tsx`, `card.tsx`)
- Never use `index.tsx` for component files

## Code Quality
- Write self-documenting code
- Use meaningful variable and function names
- Add proper JSDoc comments for complex functions
- Follow DRY principles
- Keep components focused and single-purpose
- Use direct imports instead of index files
- Always use `import * as React from "react"` when using React hooks
- Extract repeated classnames into helper functions
- Use nullish coalescing (`??`) for fallback values
- Fix all linting errors before committing
- Run `pnpm lint --fix` to auto-fix import order issues

## Performance Considerations
- Use proper React optimization techniques
- Implement proper loading states
- Use proper error boundaries
- Optimize bundle size
- Use proper caching strategies
- Implement proper HMR configuration

## Accessibility
- Use proper semantic HTML
- Implement proper ARIA attributes
- Ensure keyboard navigation
- Maintain proper color contrast
- Test with screen readers
- Support multiple languages

## Testing Guidelines
- Write unit tests for utilities
- Write integration tests for components
- Test both light and dark themes
- Test accessibility features
- Test internationalization
- Use proper testing patterns

## Git Workflow
- Use conventional commit messages
- Keep commits focused and atomic
- Write descriptive commit messages
- Use proper branching strategies
- Fix all build errors before committing

## Security
- Validate all user inputs
- Use proper authentication patterns
- Implement proper authorization
- Follow security best practices
- Sanitize data appropriately

## Documentation
- Document complex business logic
- Keep README up to date
- Document component APIs
- Use proper inline comments
- Maintain code examples
- Document i18n patterns

## Error Handling
- Use proper error boundaries
- Implement proper error states
- Use proper logging
- Handle edge cases gracefully
- Provide user-friendly error messages
- All error messages must be translatable

## Performance Monitoring
- Monitor bundle size
- Track performance metrics
- Optimize loading times
- Use proper caching
- Monitor user experience
- Monitor i18n performance

## Internationalization Best Practices
- Never hardcode strings in components
- Use descriptive translation keys
- Group related translations logically
- Support RTL languages if needed
- Test with different languages
- Use proper number and date formatting
- Handle pluralization correctly
- Default to English language
- No flag emojis in language selector
- Include translation function in useEffect dependencies when used

## API Development Patterns
- Use consistent error message patterns
- Implement proper loading states
- Use realistic network delays
- Handle errors gracefully
- Provide fallback data
- Use proper TypeScript interfaces

## Navigation and Routing
- Dashboard as initial page (`/dashboard`)
- Stat type pages: `/weight`, `/heart-rate`, `/sleep`, `/steps`
- Active link highlighting with background accent
- Extracted classname helper functions
- Consistent header and footer across all pages
- No separate home page or home link

## Build and Development
- **Build Command**: `pnpm build` - Builds for production (sourcemap warnings suppressed)
- **Type Check**: `pnpm typecheck` - Runs TypeScript compiler
- **Lint**: `pnpm lint` - Runs ESLint with TypeScript support
- **Lint Fix**: `pnpm lint --fix` - Auto-fixes import order and other issues
- **Development**: `pnpm dev` - Starts development server
- **Fix Build Errors**: Always run typecheck and lint before committing
- **Import Order**: ESLint enforces proper import ordering
- **Unused Imports**: Remove unused React imports from components
- **Sourcemap Warnings**: Suppressed in production build via Vite config

## Common Issues and Solutions
- **TypeScript Errors**: Run `pnpm typecheck` to identify and fix type errors
- **Import Order**: Run `pnpm lint --fix` to auto-fix import order issues
- **Unused Imports**: Remove unused React imports when not using hooks
- **Hook Dependencies**: Include all dependencies in useEffect dependency arrays
- **Broken Exports**: Only export files that actually exist
- **Next-themes Import**: Use proper import syntax for next-themes types
- **i18next Import**: Use `createInstance` instead of default import to avoid warnings

## Future Considerations
- Plan for scalability
- Consider additional languages
- Plan for mobile optimization
- Consider offline capabilities
- Plan for data persistence
- Consider real API integration
- Plan for user authentication
- Consider data visualization
- Implement real charts on stat pages
- Add CRUD functionality for health entries
- Consider adding unit tests
- Plan for CI/CD pipeline
